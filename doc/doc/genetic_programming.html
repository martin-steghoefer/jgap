<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="description" content="Tutorial on how to utilize Genetic Programming with JGAP.">
<meta name="keywords" content="java, genetic algorithms, framework, genetic programming, gp, population
                   optimization, evolutionary, open source, genes, alleles, chromosomes">
<link rel="stylesheet" href="../jgap.css" type="text/css">
<title>Genetic Programming with JGAP</title>
</head>

<body class="documentText">

<h1 class="docTitle">Genetic Programming with JGAP</h1>
<a class="homeLink" href="index.html">

<p align="center">[Documentation Index]</a> </p>

<hr>

<p class="text">Genetic Programming (GP) is supposed to be introduced by John
Koza. GP is sort of different to Genetic Algorithms (GA) as GP is more complex
than GA. GP is about evolving programs with a given set of commands. Each
command is assigned a number of parameters. That way, programs can be
constructed. They are represented internally as a tree. But you do not have to
cope with the internal representation. For you it is only important to know that
you can write sort of programs. Each program contains only those commands and
terminals (such as numbers or Boolean values) that you define to be used! It is
even possible evolving full-blown Java programs (see the <a href="http://jgap.sourceforge.net/doc/robocode/robocode.html">Robocode
example</a>). </p>

<p class="text">GP was introduced with JGAP 3.0. This document presents some useful information about how to utilize JGAP for GP. </p>

<h3 class="subheader">JGAP's Philosophy</h3>

<p class="text">The main philosophy that was setup before extending JGAP towards
GP was to reach the goal by adding parts to GA to get GP. Thus: GA + x =GP, with
x being the added parts.
 </p>

<h3 class="subheader">A first start</h3>

<p class="text">To get a feeling of how to implement your GP-Program with JGAP,
please have a look at the example located in class&nbsp;<i>examples.gp.MathProblem</i>.
This example tries to find a formula for a given truth table (X/Y value pairs)
and a given set of operators (such as +, -, * etc). The mentioned example class
also contains a fitness function named <i>FormulaFitnessFunction</i>. A more
complex example can be found in class <i>examples.gp.Fibonacci </i>and in class <i>examples.gp.anttrail.AntTrailProblem</i>.
 </p>

<p class="text">The math example at a glance (after that the steps are explained
in detail) :
 </p>

<p class="text">1. Create configuration
 </p>

<p class="Listing">
<tt>
  /**<br>
  &nbsp;* Starts the example<br>
  &nbsp;* @param args ignored<br>
  &nbsp;* @throws Exception<br>
  &nbsp;*/<br>
  public static void main(String[] args) throws Exception {<br>
&nbsp; GPConfiguration config = new GPConfiguration();<br>
  &nbsp; config.setGPFitnessEvaluator(new DeltaGPFitnessEvaluator());<br>
&nbsp; config.setMaxInitDepth(6);<br>
&nbsp; config.setPopulationSize(100);<br>
&nbsp; config.setFitnessFunction(new MathProblem.FormulaFitnessFunction());<br>
&nbsp; ... // continued below<br>

</tt>
 </p>

<p class="text">2. Create initial Genotype (continued from above method <i>main</i>): </p>

<p class="Listing">    
<tt>&nbsp; GPGenotype gp = create(config);<br>
}
<br>
<br>
<br>
  public static GPGenotype create(GPConfiguration a_conf) throws InvalidConfigurationException {<br>
&nbsp; Class[] types = {<br>
&nbsp;&nbsp;&nbsp; CommandGene.FloatClass};<br>
&nbsp; Class[][] argTypes = {<br>
&nbsp;&nbsp;&nbsp; {}<br>
&nbsp; };<br>
&nbsp; // Define the commands and terminals the GP is allowed to use.<br>
&nbsp; // -----------------------------------------------------------<br>
&nbsp; CommandGene[][] nodeSets = {<br>
  &nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp; vx = Variable.create(a_conf, "X", CommandGene.FloatClass),<br>
  &nbsp;&nbsp;&nbsp; new AddCommand(a_conf, CommandGene.FloatClass),<br>
  &nbsp;&nbsp;&nbsp; new SubtractCommand(a_conf, CommandGene.FloatClass),<br>
  &nbsp;&nbsp;&nbsp; new MultiplyCommand(a_conf, CommandGene.FloatClass),<br>
  &nbsp;&nbsp;&nbsp; new DivideCommand(a_conf, CommandGene.FloatClass),<br>
  &nbsp;&nbsp;&nbsp; new SinCommand(a_conf, CommandGene.FloatClass),<br>
  &nbsp;&nbsp;&nbsp; new CosCommand(a_conf, CommandGene.FloatClass),<br>
  &nbsp;&nbsp;&nbsp; new ExpCommand(a_conf, CommandGene.FloatClass),<br>
&nbsp;&nbsp;&nbsp; // Use terminal with possible value from 2.0 to 10.0 decimal<br>
&nbsp;&nbsp;&nbsp; new Terminal(conf, CommandGene.FloatClass, 2.0d, 10.0d, false),<br>
&nbsp; &nbsp; }<br>
  &nbsp; };<br>
  &nbsp; Random random = new Random();<br>
  &nbsp; // Randomly initialize function data (X-Y table) for x^4+x^3+x^2+x.<br>
&nbsp; // This is problem-specific and not necessary in other cases.<br>
&nbsp; // ----------------------------------------------------------------<br>
  &nbsp; for (int i = 0; i &lt; 20; i++) {<br>
  &nbsp;&nbsp;&nbsp; float f = 2.0f * (random.nextFloat() - 0.5f);<br>
  &nbsp;&nbsp;&nbsp; x[i] = new Float(f);<br>
  &nbsp;&nbsp;&nbsp; y[i] = f * f * f * f + f * f * f + f * f - f;<br>
  &nbsp;&nbsp;&nbsp; System.out.println(i + ") " + x[i] + "   " + y[i]);<br>
  &nbsp; }<br>
  &nbsp; // Create genotype with initial population.<br>
&nbsp; // Allow max. 100 nodes within one program.<br>
&nbsp; // ----------------------------------------<br>
  &nbsp; return randomInitialGenotype(a_conf, types, argTypes, nodeSets, 100,
  true);<br>
  }
</tt> </p>

<p class="text">3. Start the evolution and output the result: (continued in above method <i>main</i>):&nbsp; </p>

<p class="Listing">    <tt>// Do 100 evolutions in a row.<br>
// ---------------------------<br>
&nbsp; gp.evolve(100);<br>
// Output best solution found.<br>
// ---------------------------<br>
gp.outputSolution(gp.getAllTimeBest());<br>
<br>
    } // end of method &quot;main&quot;
<br>
</tt> </p>

<p class="text">4. Optional: Implement your own functions and terminals </p>

<p class="text">Please have a look at packages <i>org.jgap.gp.function</i>, <i>org.jgap.gp.terminal,</i><i>org.jgap.gp.function</i>
and <i> examples.gp.anttrail</i> for available GP functions and terminals. There you can
see how to implement your own classes and use them in the above step 2 during
setup. </p>

<p class="text">You can benefit from looking at the examples mentioned above. Go
for the code and you'll get a better feeling. It's very easy using JGAP for GP! </p>

<h3 class="subheader">Digging into detail </h3>

<p class="text">Now as promised, the steps explained in more detail. The
documentation below refers to the example above, corresponding with the step
number: </p>

<p class="text">1. Create configuration </p>

<p class="text">At first, a JGAP configuration for GP is created and setup: </p>

<p class="Listing">
<tt>
&nbsp; GPConfiguration config = new GPConfiguration();<br>
  &nbsp; config.setGPFitnessEvaluator(new DeltaGPFitnessEvaluator());<br>
&nbsp; config.setMaxInitDepth(6);<br>
&nbsp; config.setPopulationSize(100);<br>
&nbsp; config.setFitnessFunction(new MathProblem.FormulaFitnessFunction());<br>

</tt>
 </p>

<p class="text">The parameters used are: </p>

<ul>
  <li>
    <p class="text">&nbsp;fitness evaluator: the delta fitness evaluator gives
    lower fitness values a better ranking as the fitness value is seen as a
    defect rate. If you want to see the fitness value as a success rate,
    instead, please use the DefaultGPFitnessEvaluator!</li>
  <li>
    <p class="text">The maximum depth of a GP program on initialization is set
    to six. Consider a GP program. It is represented as a tree. The maximum
    number of children of the top node (which has depth zero) is six, resulting
    in a maximum depth of six. Too high values may result in bad performance of
    even a memory overflow. Six is a good value for our example. In more complex
    examples, maybe use a maximum of, say, 12.</li>
  <li>
    <p class="text">The population size, i.e. the number of coexisting GP
    programs, is set to 100. This already is a quite high value as each program
    consumes time and memory resources! If programs are getting bigger (i.e.
    having more children), time and memory consumption rises, too!</li>
  <li>
    <p class="text">Finally, the fitness function is set. It evaluates each GP
    program, which is also called an individuum. Please notice: The fitness
    function ALWAYS is specific to your problem, there is no common fitness
    function! You have to study the examples to get an idea about the
    implementation of it (later on, there will be some additional
    documentation).</li>
</ul>
<p class="text">The fitness function can be found in the JGAP code base in the
example class MathProblem.
<p class="text">2. Create initial Genotype</p>
<p class="text">The Genotype initialization and creation is done in method
create, which is called from the main method. At first follows the
initialization, divided into chunks, starting with:</p>
<p class="Listing">
<tt>
&nbsp; Class[] types = {<br>
&nbsp;&nbsp;&nbsp; CommandGene.FloatClass};<br>
&nbsp; Class[][] argTypes = {<br>
&nbsp;&nbsp;&nbsp; {}<br>
&nbsp; };<br>
</tt> &nbsp;</p>
<p class="text">As you can see there are two array, both having one dimension
and the same length, namely one. This is a must!
<p class="text">The first array, types, defines the return type of the sub
programs (which will be outlined soon). In our example, we only have one sub
program, thus the length of the arrays is one. The parameter
CommandGene.FloatClass expresses that the return type is Float.Class. This is
because CommandGene.FloatClass is just a convenient, speaking definition of
Float.Class (it is equivalent).
<p class="text">The second array, argTypes, defines the input type of so-called
Automatically Defined Functions (ADF's). They are not important here. If you
want to get insights about ADF's, please look at the MathProblem class.
<p class="Listing">
<tt>
&nbsp; // Define the commands and terminals the GP is allowed to use.<br>
&nbsp; // -----------------------------------------------------------<br>
&nbsp; CommandGene[][] nodeSets = {<br>
  &nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp; vx = Variable.create(a_conf, "X", CommandGene.FloatClass),<br>
  &nbsp;&nbsp;&nbsp; new AddCommand(a_conf, CommandGene.FloatClass),<br>
  &nbsp;&nbsp;&nbsp; new SubtractCommand(a_conf, CommandGene.FloatClass),<br>
  &nbsp;&nbsp;&nbsp; new MultiplyCommand(a_conf, CommandGene.FloatClass),<br>
  &nbsp;&nbsp;&nbsp; new DivideCommand(a_conf, CommandGene.FloatClass),<br>
  &nbsp;&nbsp;&nbsp; new SinCommand(a_conf, CommandGene.FloatClass),<br>
  &nbsp;&nbsp;&nbsp; new CosCommand(a_conf, CommandGene.FloatClass),<br>
  &nbsp;&nbsp;&nbsp; new ExpCommand(a_conf, CommandGene.FloatClass),<br>
&nbsp;&nbsp;&nbsp; // Use terminal with possible value from 2.0 to 10.0 decimal<br>
&nbsp;&nbsp;&nbsp; new Terminal(conf, CommandGene.FloatClass, 2.0d, 10.0d, false),<br>
&nbsp; &nbsp; }<br>
  &nbsp; };<br>
</tt> 
<p class="text">Here, the valid sets of commands (functions and terminals) is
defined. This means: a GP program will be evolved randomly, but by using one or
more of the commands defined in nodeSets, each command can be used more than
once, potentially. Please notice, that the variable &quot;X&quot; is set in the
fitness function to inject an input value! Also notice, that the last parameter
of the variable denotes the return type of the variable, i.e Float.class (or:
CommandGene.FloatClass). This is comparable&nbsp; to the declaration in array
types, above in this step.<p class="text">Each command used can either be a
function or a terminal. A function has at least one input parameter whereas a
terminal never has an input parameter. A terminal is a constant, like a number
or a boolean value. You can find a lot of prefabricated functions and terminals
in packages <i>org.jgap.gp.function</i> and&nbsp; <i>org.jgap.gp.terminal</i>.
It is important to notice that each function or terminal must support at least
one return type. E.g., that means for a terminal representing a number, it must
at least support either a float, an integer, a double, a short or a byte number.
It <i>can</i> support all of them, but <i>must </i>implement at least one. See <i>org.jgap.gp.terminal.Constant</i>
for a simple example. In class <i>org.jgap.gp.terminal.Terminal</i>, there is a
more complex example, with fixed numbers that can be mutated and thus have to be
mapped to be within the specified bounds.<p class="text">Functions returning a
number have to be setup in analogy: They can support multiple return types like
int, float and double, but they must support at least one of them. With numbers
it is easy to imagine: it is OK to return either a float value, say, 47.11f, or
alternatively, the truncated integer value, 47. See class <i>org.jgap.gp.function.Add</i>
for an example, look for the <i>execute_XXX</i> functions where the different
return types are realized.<p class="text">Functions have a number of input
parameters, this is called the arity of the function. Arity two means: two input
parameters. The arity is setup during construction of each function via its base
class, also see the Add-class for example. In the constructor, the return type
is defined, too.<p class="text">A function can have input parameters with
different types. Consider the IF-Statement (IF &lt;condition&gt; THEN
&lt;command&gt;). The first parameter is a boolean value. Besides, number values
could be supported, with a number bigger than zero being seen as true and all
other numbers representing false. The second parameter is a void type. See class
org.jgap.gp.function.IfElse (especially method getChildType) for an example of
this extended type handling for children. 
<p class="Listing">
<tt>
  &nbsp; Random random = new Random();<br>
  &nbsp; // Randomly initialize function data (X-Y table) for x^4+x^3+x^2+x.<br>
&nbsp; // This is problem-specific and not necessary in other cases.<br>
&nbsp; // ----------------------------------------------------------------<br>
  &nbsp; for (int i = 0; i &lt; 20; i++) {<br>
  &nbsp;&nbsp;&nbsp; float f = 2.0f * (random.nextFloat() - 0.5f);<br>
  &nbsp;&nbsp;&nbsp; x[i] = new Float(f);<br>
  &nbsp;&nbsp;&nbsp; y[i] = f * f * f * f + f * f * f + f * f - f;<br>
  &nbsp;&nbsp;&nbsp; System.out.println(i + ") " + x[i] + "   " + y[i]);<br>
  &nbsp; }<br>
</tt> 
<p class="text">As the fitness function should compare the results of the
evolved GP program (i.e. a mathematical function!) with a truth table, we
initialize this truth table once at the beginning with fixed, but random input
numbers. Instead of these random numbers, it would be perfectly OK to use
subsequent values from, say, 0 to 20.
<p class="Listing">
<tt>
  &nbsp; return randomInitialGenotype(a_conf, types, argTypes, nodeSets, 100,
  true);<br>
</tt>  
<p class="text">This returns the initialized genotype, using the
above-discussed, initialized parameters. The last two parameters are as follows.
The number 100 is the maximum number of nodes to reserve space for in memory for
each GP program. If you have a program spanning a <b>full</b> binary tree with
depth of six, then you&nbsp; would need 127 nodes (2^(n+1) - 1, n = 6). The last
parameter, true, controls that the system outputs verbose messages. This does
not influence evolution itself, but maybe useful for analyzing and reduces speed
a bit.  
<p class="text">3. Start the evolution
<p class="text">This is easy, see the code in step 3 at the beginning. It is
self-explanatory.
<p class="text">4. Implement your own functions and terminals
<p class="text">For now, please see the functions and terminals in packages <i>org.jgap.gp.function</i>
and&nbsp; <i>org.jgap.gp.terminal.</i>
<p class="text">To be continued...: Explain how
<p class="copyright">Copyright © 2006-2008 <a href="http://www.klaus-meffert.com" target="_blank"> Klaus
Meffert</a>. All rights reserved. </p>

<hr>
<a class="homeLink" href="index.html">

<p align="center">[Documentation Index]</a> <br>
<a href="http://sourceforge.net/projects/jgap"><img
src="http://sourceforge.net/sflogo.php?group_id=11618&amp;type=5" width="210" height="62"
border="0" alt="SourceForge Logo"></a> </p>
</body>
</html>
